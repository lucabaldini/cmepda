\documentclass[9pt]{beamer}
\usetheme{cmepda}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\graphicspath{{figures/}} 


\title{OOP introduction (1/2)}
\subtitle{Computing Methods for Experimental Physics and Data Analysis}
\date{Compiled on \today}
\author{A. Manfreda}
\institute[INFN]{INFN--Pisa}
\email{alberto.manfreda@pi.infn.it}


\begin{document}


\titleframe


\begin{frame}
  \frametitle{Smart variables}
  
  \begin{itemize}
    \item Working with containers like lists or dictionaries, you may have noticed
          that they can do many thing besides holding the data
    \medskip
    \begin{itemize}
      \item You can extend a list using append() or insert()
      \item Trying to access a non-existent index in a list triggers a specific errror (\emph{IndexError})
      \item You can iterate on a list using the handy for-loop Python syntax
      \item and so on\dots
     \end{itemize}
     \medskip
     \item In other words, a list is a variable that, in addition to its data,
           shows some kind of specific \emph{behaviour}.
     \medskip
     \item How is that implemented?
  \end{itemize}
\end{frame}



\begin{frame}
  \frametitle{Object Oriented Programming (OOP)}
  
  \begin{itemize}
    \small
    \item Programming paradigm based on \emph{objects}
    \bigskip
    \item An object is a code entity that has:
    \smallskip
    \begin{itemize}
      \item \alert{State} $\rightarrow$ data (usually called \emph{member variables} or \emph{attributes})
      \smallskip
      \item \alert{Behaviour} $\rightarrow$ functions (usually called \emph{member functions} or \emph{methods})
    \end{itemize}
    \bigskip
    \item The idea is: keep together the variables and the code that manipulates them
    \bigskip
    \item As the name suggests, OOP is very often adopted for modelling systems that are naturally
          described in terms of objects  
    \begin{itemize}
      \smallskip
      \item Physical simulations
      \smallskip
      \item Graphical engines
      \smallskip
      \item Graphical User Interfaces (GUI) 
    \end{itemize}

  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Why should I care?}
  
  \begin{itemize}
    \item Object-oriented programming is one of the most widely used paradigm today
    \smallskip
    \item That doesn't necessarily mean it is the best one -- nor the right tool for any job \\
    \tiny
    \url{https://en.wikipedia.org/wiki/Object-oriented_programming\#Criticism}
    \normalsize
    \smallskip
        
    \item There is a number of famous programmers which really dislike it (e.g. \emph{Linus Torvalds})
    \medskip
    \item Still, it is something you definitely want in your toolbox
    \medskip
    \item And there is a fairly good chance that you will have to interact with some OOP
          code in your life
    \smallskip   
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{A good reason for learning OOP}
  
  \begin{itemize}
    \item (Almost) every popular languages nowadays is OO
  \end{itemize}
  
  \smallskip
  
  \centering\includegraphics[width=0.9\textwidth]{thiobe.png}
  
  \smallskip
  
  \tiny \url{https://www.tiobe.com/tiobe-index/} \normalsize
  
  \smallskip
  
  \begin{itemize}
    \item Besides C of course!
  \end{itemize}
  
\end{frame}



\begin{frame}
  \frametitle{OOP: Classes and Objects}
  
  \begin{itemize}
  \item Basic defnitions:
    \begin{itemize}
    \item A \alert{class} is a blueprint for creating objects
    \item An \alert{object} is a concrete relization of a class
    \end{itemize}

  \smallskip
  
  \item You can imagine a class like a project, which is used to
        describe how objects are built and how they works

  \smallskip

  \item You can have multiple objects of the same class
  
  \smallskip
  
  \item The relationship is similar to the one between types and variables:
    \begin{itemize} 
    \item A type is an abstract concept, describing how a varibale is
          represented in memory
    \item A variable is a concrete realization of it
    \item You can have several variables of the same type (like several integers
          or several strings)
    \end{itemize}
  
  \smallskip
  
  \item Indeed, to some extent, a class is the generalization of the concept of
        type. It specifies not only how an object \emph{is made} but also how \emph{it behaves}.
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{OOP: an example}
  \centering\includegraphics[width=0.2\textwidth]{television.png}
  
  \medskip
  
  \begin{itemize}
  \item Let's consider a familiar object, like a television. It has:
    \smallskip
    \begin{itemize}
    \item A state
      \begin{itemize}
      \item On/off (and possibly standby)
      \item Currently displayed channel
      \item Volume
      \item Brightness, contrast, etc\dots
      \end{itemize}

    \medskip
    
    \item A behaviour
      \smallskip
      \begin{itemize}
      \item Pressing the `power' button will turn ON/OFF
      \item Rotating the volume knob will increase/decrease the volumne
      \item Using the buttons on the remote control will change displayed 
            channel, brightness, contrast etc\dots
      \item And don't forget you need to plug-in before use!
      \end{itemize}
    \end{itemize}
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{OOP: an example}
 
  \begin{itemize}
    \item How would that be represented in the code?
    \smallskip
      \begin{itemize}
      \item The state can be represented by some attributes (variables):
      \begin{itemize}
        \item A boolean can represent the ON/OFF state
        \item For the currently displayed channel you can use an integer
        \item Volume, contrast, luminosity etc\dots they all get their own variable(s)
      \end{itemize}

      \medskip
    
      \item The behaviour canb be implemented through the methods:
      \smallskip
      \begin{itemize}
        \item For example the turn\_on() and turn\_off() functions may change the value of the variable
              and also produce all the related changes (i.e. start/stop video and audio) 
        \item You will probably have the netx\_channel() and previous\_channel() functions for zapping and so on\dots
        \item Of course it can be much more complex than that!
      \end{itemize}
    \end{itemize}
    
    \medskip
    
    \item Attributes and methods are collectively called \alert{members} of the class
    \medskip
    \item Each object of a specific class is an \alert{instance} of that class
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Python classes}
  \input{pygments/class_tv_basic}
\end{frame}


\begin{frame}
  \frametitle{Bonus}
  \framesubtitle{In Python everything is an object of some class!}
  \input{pygments/everything_is_a_class}
\end{frame}


\begin{frame}
  \frametitle{Methods}
  \input{pygments/class_methods}
\end{frame}


\begin{frame}
  \frametitle{Attributes}
  \input{pygments/class_attributes_1}
\end{frame}


\begin{frame}
  \frametitle{Constructor}
  
  \begin{itemize}
    \small
    \item Adding attributes like that would be crazy\dots what would happen if I forgot
          to call the 'add\_a\_class\_attribute()' method in the previous example?
    \medskip
    \item Luckily there is a solution for that: the class \alert{constructor}
    \medskip
    \item The constructor is a special method that is called automatically each time
          a class istance is created
    \medskip
    \item A specificity of the constructor is that it cannot return anything
    \medskip
    \item In Python the constructor is the \emph{\_\_init\_\_} method%
          \footnote{Actually the real constructor -- that is the function responsible for 
                    creating the class instances -- is the \emph{\_\_new\_\_} operator, but 99\% of the time you don't need
                    to define that, as all classes have a default one which does the job for you}           
    \medskip
    \item Class methods like \emph{\_\_init\_\_}, with the name surronded by two underscores,
          are called \alert{special} methods or \alert{dunder} methods.
    \medskip
    \item Is is good practice to define all your class attributes inside the constructor!

  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Constructor}
  \input{pygments/class_constructor}
\end{frame}


\begin{frame}
  \frametitle{Digression - namespaces}
  
  \begin{itemize}
    \small
    \item 'Namespaces are one honking great idea -- let's do more of those!'
            (\emph{Tim Peters - The Zen of Python})
    \medskip
    \item A \alert{namespace} in Python is a essentially a ditcionary of \emph{unique} names, each one associated to an object (which can be anything: a variable, a function, a class etc\dots)
    \medskip
  \end{itemize}
  
  \centering\includegraphics[width=0.25\textwidth]{types_namespace.png}
  
  \begin{itemize}
    \small
    \item Python creates separate namespaces for many things: for example, each time a function is called a namespace for local variables is created
    \medskip 
    \item You can access objects in the local namespace (and those above -- 
          see picture) just with their name(s); for others you need
          the '.' (dot) operator.
    \medskip
    \item The space of visibility of a variable is called it \alert{scope}.
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Instance attributes vs class attributes}
  
  \begin{itemize}
    \small
    \item Each class has a namespace. Plus, each istance of the class get its own additional namespace
    \medskip
    \item The class namespace is automatically visible from each instance namespace, but not the opposite
    \medskip
    \item An attribute in an instance namesespace is an \alert{instance attribute}, and cannot be seen or modified
          by other instances of the class
    \medskip
    \item An attribute in the class namespace is a \alert{class attribute} and is shared among all the instances
    \medskip
    \item Since class attributes are not related to a specific instance, they can be accessed without creating one!
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Class attributes}
  \framesubtitle{(And their strange behaviour)}
  \input{pygments/class_attributes_2}
\end{frame}


\begin{frame}
  \frametitle{Short summary}
  
  \begin{itemize}
    \footnotesize
    \item Object Oriented Programming (OOP) is a widespread programming paradigm,
          supported by many programming languages (old and modern), including Python
    \medskip
    \item An object has a state and a behaviour, represented by member variables (attributes)
          and member functions (methods) respectively
    \medskip
    \item A class is a blueprint for creating objects, each object is an instance of a class
    \medskip
    \item In Python classes are defined with the 'class' keyword and instanciated with the '()' operator
    \medskip
    \item Class attributes and methods (globally called members) are accessed through the '.' operator
    \medskip
    \item All the class methods get the object istance as their first argument (usually named 'self')
    \medskip
    \item You should declare class attributes in the constructor a.k.a. the \emph{\_\_init\_\_} function
    \medskip
    \item Instance attributes are not shared: each instance has its own copy of the data
    \medskip
    \item Class attributes are declared outside methods and are shared among all the instances of a class
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Encapsulation - hidden state and interfaces}
  \framesubtitle{Back to the TV example}
  
  \centering\includegraphics[width=0.2\textwidth]{television.png}
  
  \bigskip
  
  \begin{itemize}
  \item Note that part of the state is hidden from the user:
    \begin{itemize}
    \item E.g. internal switches, transistors, etc\dots
    \end{itemize}
  \smallskip
  \item You do not need to know what's going on inside the case to operate a TV!
  \smallskip
  \item All you need to know is how to use the \alert{interface} (the remote
        control, the knobs, the power button, the plug\dots)
  \smallskip
  \item The \alert{implementation} details are hidden: only the TV producer cares about
        them, not the user. 
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Encapsulation}
  
  \begin{itemize}
    \item This leads us to the concept of \alert{encapsulation} 
    \bigskip
    \begin{itemize}
      \item \emph{The state of an object should only be accessed and altered
                  through its publicly exposed interface}
    \end{itemize}
    \bigskip
    \item That way it is easier to find bugs: you know that, if something is wrong
          with an object, the problem lays inside the class code
    \bigskip
    \item That way you can also \emph{enforce behaviour}: for example you can
          prevent from changing the channel if the TV is off
    
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Enforcing behaviour}
  \input{pygments/class_tv_zapping}
\end{frame}


\begin{frame}
  \frametitle{Advantages of encapsulation}
  
  \begin{itemize}
    \item This is a good idea for several reasons:
    
    \medskip
    
    \begin{itemize}
      \item The development of a part (e.g. `the television') is clearly separated
            from the rest of the project (e.g. `the dvd reader')
      \medskip
      \item An object can be reused in different contexts: you can easily connect
            the same TV to the dvd reader, the game consol or the VHS, 
            provided that the required interface (port + cable) is the same
      \medskip
      \item You can even change your object, for example buy a new model,
            and, as long as the interfaces are the same, you will still be able 
            to use it in the same way!
    \end{itemize}
    
    \medskip
  
    \item These advantages may be extremely important for large-scale project!

  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Challenge: how do you get \emph{real} encapsulation?}
  \begin{itemize}
    \item At this point you may be wondering: I can read and modify any class attribute 
          from outside the class using the '.' (dot) operator! 
          Doesn't that break encapsulation?
          
    \bigskip
    
    \item Answer: Yes it does - but there are ways to fix it!
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{How do you get \emph{real} encapsulation?}
  \framesubtitle{Digression - the boring languages}
  
  \begin{itemize}
    \item In languages like C++ you can explicitly declare that some class
          attributes (and methods) are \emph{private}
    \medskip
    \item Private attributes cannot be accessed outside the class - the compiler enforce that!
    \medskip
    \item There is this sort of common wisdom that dictates that \emph{all} class data should be private
    \medskip
    \item If you really want to provide access to some of them, you can use the infamous 'getters' and 'setters' methods
    \medskip
    \item That's a lot of code to write - plus, it's not the pythonic way!
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Pythonic encapsulation}
  
  \begin{itemize}
    \item In Python there is no concept of \emph{enforced} private attributes
    \medskip
    \item However, there exists a convention that any attribute/method name prepended by one or two underscore(s) should be considered "private"
    \medskip
    \item It's like a warning for the class user: you should never access that directly!
    \medskip
    \item In the case of two underscores Python will actually do a subtle thing to help keeping the data private -- it will 
          prepend \_\emph{classname} to the actual attribute name (see next example)
    \medskip
    \item However, not everyone in the Python community loves that
    \medskip
    \item "Never, ever use two leading underscore. This is annoyngly private"\\
           \vspace{0.02\textheight}
           \footnotesize [\emph{Alex Martelli}, member of the Python Software Foundation, author of 'Python in a Nutshell' and co-author of 'The Python cookbook']
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{"Private" attributes in Python}
  \input{pygments/class_tv_private}
\end{frame}


\begin{frame}
  \frametitle{Pythonic encapsulation}
  
  \begin{itemize}
    \small
    \item The possibility of making variables "private" (enforced or not) is not enough of course,
          because sometimes we still want to let the user read or even modify the value of the attribute
    \bigskip
    \item The "old" solution for that is providing getters/setters
    \bigskip
    \item But the awsome solution is using \alert{properties} (since Python 2.2)
    \bigskip
    \item Properties look similar to getters and setters, but with a twist: you keep
          accessing the attribute with the dot operator
    \bigskip
    \item That is a \emph{huge} advantage: it means you can start without them, and add the code only if really needed!
    \bigskip
    \item Let's compare the two methods in the following example
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Example of a class without encapsulation}
  \input{pygments/class_tv_encapsulation_none}
\end{frame}


\begin{frame}
  \frametitle{Old-style encapsulation: never do that!}
  \input{pygments/class_tv_encapsulation_old}
\end{frame}



\begin{frame}
  \frametitle{Pythonic encapsulation with properties}
  \input{pygments/class_tv_encapsulation_properties_verbose}
\end{frame}


\begin{frame}
  \frametitle{Even more pythonic encapsulation}
  \input{pygments/class_tv_encapsulation_properties}
\end{frame}


\begin{frame}
  \frametitle{Interface vs implementation mindset}
  \framesubtitle{physicists vs programmers}
  
  \begin{itemize}
    
    \item A physicist thinks:
        
    \medskip
      
    \begin{itemize}
      \item "I have this super-cool algorithm to solve the problem I am working on:
             I will code it carefully, than put together quickly some basic 
             interface to pass data to it and write results to screen / file.
             I need the results quickly for my paper; I can always improve the 
             interface later, right?"
    \end{itemize}
    \medskip
      
    \item A programmer thinks:
    
    \medskip
    
    \begin{itemize}
      \item "I will create a nice interface for the user to handle input/output
             in different formats and I will try to keep it as stable as 
             possible in the future.
             I will start with no algorithm at all -- I will just use random
             numbers to test the interface. I can always implement the
             actual algorithm later, right?"
    \end{itemize}

  \end{itemize}

\end{frame}
 
 
\begin{frame}
  \frametitle{Interfaces}
    
  \begin{itemize}
    \item You don't need to think like a programmer - doing physics is your goal - but
          remember that \alert{interfaces are important}
    \medskip
    \item The concept of interface does not just apply to the program as a whole:
          every significant portion of code (function, class) has its interface
    \medskip
    \item The interface of a class in Python is made by all its "public" members (methods and attributes)
          -- i.e. those without an underscore at the beginning of their name
    \medskip
    \item Changing the interface may break every other piece of code that uses it.
          You want to do that \emph{as less as possible}
    \medskip
    \item You should not access "private" members directly - even if you can. Always
          pass through the interface
    
  \end{itemize}

\end{frame}


\begin{frame}
  \frametitle{Short summary (2)}
    
  \begin{itemize}
    \small
    \item Encapsulation is the technique of hiding part or all the class state to the user; 
          he can only access and modify that through the class methods
    \medskip
    \item Encapsulation helps debugging by limiting the number of places in the code
          that can mutate the state of an object
    \medskip
    \item It can also be useful to enforce behaviour  
    \medskip
    \item Encapsulation in Python is not enforced by the language, but rather relies on conventions
    \medskip
    \item Class members with an underscore at the beginning of their name are
          considered 'private' and should not be accessed directly oustide the class
    \smallskip
    \item You can use properties to encapsulate your data at any moment in time - never use 'getters' and 'setters'
    \medskip
    \item Interfaces should not change frequently!
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Inerithance}
  \framesubtitle{What and Why}
    
  \begin{itemize}
    \small
    \item Suppose for a moment that you are coding the Monte Carlo for a physics experiment
    \medskip
    \item You want to simulate interactions of charged particles in some detector using OOP paradigm
    \medskip
    \item You may have a class Detetctor and a class for each particle that you need to simulate
    \medskip
    \item Let's say you have a class Electron, a class Positron, a class Proton and a class Alpha
    \medskip
    \item If you think about it, these classes will have a lot of code in common
    \medskip
    \item For example they all need to store their mass, charge, position, velocitiy (or momentum), possibly spin etc\dots
    \medskip
    \item They may also have similar behaviour, though that is less obvious
    \medskip
    \item We know that duplicate code is evil (DRY): how do we avoid that?
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Inerithance}
  \framesubtitle{What and Why}
    
  \begin{itemize}
    \small
    \item Many languages - including Python offer a solution for that: \alert{inheritance}
    \medskip
    \item A class can inherit from another one, automatically obtaining all its functionalities (attributes and methods) and then extending or specialyzing them
    \medskip
    \item The class which we inherit from is called \emph{Base} class, \emph{Parent} class or (in Python) \emph{Superclass}
    \medskip
    \item The class inheriting is called \emph{Derived} class or \emph{Child} class
    \medskip
    \item In our problem we can imagine to have a base class 'Particle' and many specialized classes inheriting from it
    \medskip
    \item Inheritance is transtive: if class C inherits from class B, and class B inherits from class A, then class C is also a child of class A (and posses all its functionalities)
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Inheritance: a basic example}
  \input{pygments/inheritance}
\end{frame}


\begin{frame}
  \frametitle{Overload}
  \input{pygments/overload}
\end{frame}


\begin{frame}
  \frametitle{Multiple inheritance}
  \input{pygments/multiple_inheritance}
\end{frame}


\begin{frame}
  \frametitle{Inerithance}
  \framesubtitle{Infernus Linnaei}
  
  \centering
  \includegraphics[width=0.40\textwidth]{linneo.jpg}~\quad%
  \includegraphics[width=0.55\textwidth]{tassonomy.jpg}
  
  \bigskip
    
  \begin{itemize}
    \item Don't abuse inheritance!
    \medskip
    \item Though bringing order to the World may look appealing\dots
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Inerithance}
  \framesubtitle{A real case example}
  
  \centering
  \includegraphics[width=0.8\textwidth]{tk-widgets.png}
   
  \tiny \url{https://wiki.python.org/moin/TkInter} \normalsize
    
  \smallskip
  \begin{itemize}
    \item {\dots}the result may be more complicated than you expect!
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Composition}
    
  \begin{itemize}
    \item \alert{Composition} is a different technique for reusing functionalities
    \medskip
    \item The concept is simple: just use an object of some class as a member of
          a different one
    \medskip
    \item For example we can create the classes 'Enigne' and 'Wheel' and than 
          the class 'Car' will have a member of type Engine and 4 members of
          type Wheel
    \medskip
    \item A class like 'Car' in the example is sometimes called an 
          \alert{aggregate} class
  \end{itemize}
  
\end{frame}


\begin{frame}
  \frametitle{Composition}
  \input{pygments/composition}
\end{frame}


\begin{frame}
  \frametitle{Composition vs Inheritance}
    
  \begin{itemize}
    \item Composition models a \alert{'has-a'} relation in the real world: a 
          Car \emph{has} a Engine
    \medskip
    \item Inheritance models a \alert{'is-a'} relation in the real world: an
          Electron \emph{is} a Particle
    \medskip
    \item It may not always be obvious which one to use in your specific case:
          choose wisely!
  \end{itemize}
  
\end{frame}



\begin{frame}
  \frametitle{Pitfalls of Inerithance}
    
  \begin{itemize}
    \item Inheritance is a wild beast. There are entire libraries written about how and when (not) to use it
    
    \bigskip
    
    \item Question for you: should a Square inherits from a Rectangle?
    \item Seems legit: a Square \emph{is} a specialized Rectangle
    \item But what happens if the Rectangle class has a changeHeight() method?
    \bigskip
    
    \bigskip
    
    \item \alert{Liskov Substitution Principle}: you should always be able to use
          a derived class instead of a base class in your code
    \item In other words: a derived class should always extend or specialize
          the functionalities of the base class, never restrict them!
   \end{itemize}
  
\end{frame}



\begin{frame}
  \frametitle{Short summary (3)}
    
  \begin{itemize}
    \item A class can inherit funcionalities from one or more other classes (Inheritance)
    \medskip
    \item The class that inherits is call Derived (or Child) class the inherited one is the Base (or Parent) class
    \medskip
    \item Inheritance models an \emph{is-a} relationship
    \medskip
    \item Classes can also incorporate other objects as class members (Composition)
    \medskip
    \item Composition models an \emph{has-a} relationship
    \medskip
    \item Inheritance is tricky: use it with care!
   \end{itemize}
  
\end{frame}



\end{document}
